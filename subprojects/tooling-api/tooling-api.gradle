import groovy.xml.XmlUtil
import org.gradle.build.*

// GradleConnector entry point requires Java 5
sourceCompatibility = javaVersion.java9Compatible ? 1.6 : 1.5

configurations {
    testPublishRuntime
}

dependencies {
    compile project(':core')
    compile project(':messaging')
    compile project(':wrapper')
    compile project(':baseServices')
    publishCompile libraries.slf4j_api

    testFixturesCompile project(':baseServicesGroovy')
    testFixturesCompile project(':internalIntegTesting')
    testCompile libraries.groovy

    // Need these to be loaded into the integTestRuntime, so that the modules are available on the classpath and the services can be registered
    // I think this is only really required for the TAPI tests in embedded mode, where we use `GradleConnector.useClasspathDistribution()`.
    integTestRuntime project(':ide')
    integTestRuntime project(':buildInit')
    integTestRuntime project(':buildComparison')
    integTestRuntime project(":ivy")
    integTestRuntime project(":maven")
    integTestRuntime project(":compositeBuilds")

    integTestRuntime project(":toolingApiBuilders")
}

useTestFixtures()
useTestFixtures(project: ":logging")
useTestFixtures(project: ':dependencyManagement')
useTestFixtures(project: ':ide')

forkingIntegTest {
    if (isCiServer) {
        maxParallelForks = Math.min(2, rootProject.maxParallelForks)
    }
}

parallelIntegTest {
    enabled = false //tooling integ tests use parallel settings, don't run
}

daemonIntegTest {
    enabled = false //tooling integ tests use daemon anyway, don't rerun
}

task shadedJarWithoutVersion(type: ShadedJar) {
    ext.outputDir = file("$buildDir/shaded-jar")
    sourceFiles = jar.inputs.files +
        files { (configurations.runtime - configurations.publishCompile).collect { zipTree(it) } }
    analysisFile = file("$outputDir/analysis.txt")
    classesDir = file("$outputDir/classes")
    jarFile = file("$outputDir/gradle-tooling-api-shaded-${version}.jar")
    keepPackages = ["org.gradle.tooling"]
    unshadedPackages = ["org.gradle", "org.slf4j"]
    ignorePackages = ["org.gradle.tooling.provider.model"]
    shadowPackage = "org.gradle.internal.impldep"
}

task toolingApiJar(type: Zip) {
    dependsOn shadedJarWithoutVersion, project(':versionInfo').createBuildReceipt
    from zipTree(shadedJarWithoutVersion.jarFile)
    from(project(':versionInfo').createTestBuildReceipt) {
        into '/org/gradle'
    }
    baseName = 'gradle-tooling-api-shaded'
    destinationDir file("$temporaryDir/")
    extension 'jar'
    version version
}

task testToolingApiJar(type: Zip) {
    dependsOn shadedJarWithoutVersion, project(':versionInfo').createTestBuildReceipt
    from zipTree(shadedJarWithoutVersion.jarFile)
    from(project(':versionInfo').createTestBuildReceipt) {
        into '/org/gradle'
    }
    baseName = 'gradle-tooling-api-shaded'
    destinationDir file("$temporaryDir/")
    extension 'jar'
    version testedVersion
}

apply from: 'buildship.gradle'

sourceJar {
    configurations.compile.allDependencies.withType(ProjectDependency).each {
        from it.dependencyProject.sourceSets.main.groovy.srcDirs
        from it.dependencyProject.sourceSets.main.java.srcDirs
    }
}

eclipse {
    classpath {
        file.whenMerged { classpath ->
            //**TODO
            classpath.entries.removeAll { it.path.contains('src/test/groovy') }
            classpath.entries.removeAll { it.path.contains('src/integTest/groovy') }
        }
    }
}

task generateFixedVersionPom {
    dependsOn generatePom
    ext.fixedVersionPomFile = new File(temporaryDir, 'pom.xml')
    outputs.files(fixedVersionPomFile)
    inputs.file { generatePom.pomFile }
    inputs.property("testedVersion", { testedVersion })
    doLast {
        def xml = new XmlParser().parse(generatePom.pomFile)
        xml.version[0].value = testedVersion
        fixedVersionPomFile.parentFile.mkdirs()
        fixedVersionPomFile.createNewFile()
        fixedVersionPomFile.text = XmlUtil.serialize(xml)
    }
}

artifacts {
    publishRuntime file: toolingApiJar.archivePath, name: archivesBaseName, type: 'jar', builtBy: toolingApiJar

    testPublishRuntime jar
    testPublishRuntime sourceJar
    testPublishRuntime file: testToolingApiJar.archivePath, name: archivesBaseName, type: 'jar', builtBy: testToolingApiJar
    testPublishRuntime new org.gradle.api.internal.artifacts.publish.DefaultPublishArtifact(archivesBaseName, 'pom', 'pom', null, new Date(), generateFixedVersionPom.fixedVersionPomFile, generateFixedVersionPom)
}

task publishLocalArchives(type: Upload) {
    configuration = configurations.testPublishRuntime
    dependsOn generateFixedVersionPom
    uploadDescriptor = false
    repositories {
        ivy {
            artifactPattern "${rootProject.file('build/repo')}/${project.group.replaceAll('\\.', '/')}/${archivesBaseName}/${testedVersion}/[artifact]-${testedVersion}(-[classifier]).[ext]"
        }
    }
}

integTestTasks.all {
    dependsOn(publishLocalArchives, ':distributions:binZip')
}

verifyTestFilesCleanup.errorWhenNotEmpty = false

